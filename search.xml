<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/24/hello-world/"/>
      <url>2021/04/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引基础</title>
      <link href="2021/04/17/mysql%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/17/mysql%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h2><h3 id="三种数据结构"><a href="#三种数据结构" class="headerlink" title="三种数据结构"></a>三种数据结构</h3><ul><li>三种数据结构：哈希表，有序数组，搜索树；</li><li>哈希表结构适用于等值查询的场景</li><li>有序数组适用于静态存储引擎，查询多，改动少；</li><li>二叉搜索树:查找 O(logN)，插入也是O(logN)；</li></ul><h3 id="Innodb的索引模型"><a href="#Innodb的索引模型" class="headerlink" title="Innodb的索引模型"></a>Innodb的索引模型</h3><p>1.每一个索引在 innodb里对应一棵B+树；</p><p>2.根据叶子节点内容分：主键索引和非主键索引：</p><ul><li>主键索引：叶子节点存整行数据；</li><li>非主键索引：叶子节点存主键的值；</li></ul><p>3.<strong>提问：基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>查询语句：<code>select * from T where ID = 1</code>主键查询方式，只搜索ID这棵B+树；</li><li>查询语句：<code>select * from T where k = 1</code>，普通索引方式，先找k索引B+树，找到对应的ID，再找ID索引树。<strong>回表</strong>； </li></ul><p>4.普通索引的查询会多扫描一棵索引树；</p><p>5.Innodb是一棵N叉树，N的值是1200；</p><p>6.提问：一张没有主键的表，只有1个普通索引，查询时怎么回表？</p><p>   Innodb默认会将RowId作为主键；</p><p>7.思考题：<code>老师你好：之前看过一遍文章，一直有疑惑：一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，文章阐述的原因是主键索引和数据行在一起，非常大搜索慢，我的疑惑是：通过普通索引找到主键ID后，同样要跑一遍主键索引，还望老师解惑。。。</code></p><ol start="8"><li>B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。</li></ol><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>1.回表：回到主索引树搜索的过程，普通索引的查找就需要；</p><p>2.示例：<code>select ID from T where k between 3 and 5</code>，需要查找的ID在k索引树上已经存在了，可以直接获取结果，不需要回表。简而言之，在<strong>这个查询里索引k已经覆盖了查询需求，称为覆盖索引</strong></p><p>3.<strong>重点：覆盖索引可以减少树的搜索次数，提升查询性能，所以使用覆盖索引是常用的性能优化手段</strong>；</p><p>4.思考通过身份证号去查询姓名，在身份证号建立索引 和 （身份证号、姓名）联合索引对比？</p><p>   使用联合索引可用到覆盖索引，不需要回表查，减少了执行时间</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>1.B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录，最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符；</p><p>示例，查询（姓名，年龄）联合索引的表，找已张开头的数据<code>where name like &#39;张%&#39;</code>索引仍然有效</p><p>2.联合索引内的字段顺序如何安排？</p><p>   <strong>重点：第一原则，如果通过调整顺序，可以少维护一个索引，那么这个顺序就是优先考虑的</strong>，示例（a, b）联合索引，则不需要在a上建立索引了。</p><p>3.MySQL5.6之后引入了<strong>索引下推</strong>，在索引遍历过程中，对索引包含的字段进行判断，过滤掉不满足条件的记录，减少回表次数；</p><p>4.提问，什么情况下需要重建索引？</p><p>  索引因为删除，或者页分裂等原因，使得数据页有空洞，重建索引会创建新的索引，把数据按顺序插入，使得页面利用率最高。语句：<code>Alter table T engine=Innodb</code></p><p>示例：<code>让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.只能是重新建表才能重建索引.</code></p><h3 id="提问F-amp-Q"><a href="#提问F-amp-Q" class="headerlink" title="提问F&amp;Q"></a>提问F&amp;Q</h3><p>1.联合索引的技巧？（覆盖索引，最左前缀原则，索引下推）</p><p>2.<strong>好问题：</strong>老师，下面两条语句有什么区别，为什么都提倡使用2:<br>   <code>1.select * from T where k in(1,2,3,4,5)</code><br>   <code>2.select * from T where k between 1 and 5</code></p><p>   第1个树搜索5次，第2个树搜索1次。</p><h1 id="MySQL基础06-07"><a href="#MySQL基础06-07" class="headerlink" title="MySQL基础06-07"></a>MySQL基础06-07</h1><p>极客时间《MySQL实战45讲》</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><strong>按照加锁范围，分为：全局锁、表级锁、行级锁</strong></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>1.对整个数据库实例加锁，MySQL提供了加全局读锁的方法，命令<code>flush tables with read lock</code>（FTWRL），让库处于只读状态；</p><p>2.应用场景：全库逻辑备份；</p><p>3.备份期间不加锁有什么问题？得到的备份库不是一个逻辑时间点的，这个视图是逻辑不一致的；</p><p>4.给整个数据库加只读锁，为什么不用<code>set global readonly=true</code>的方式呢？</p><p> （a.readonly可能用于其他逻辑，比如判断是主库还是从库；b.异常处理机制上，如果客户端发生异常断开，FTWRL方式会自动释放全局锁，而设置readonly的方式，数据库会一直保持改状态）</p><p>5.备份方式，官方自带的逻辑备份工具mysqldump，使用参数<code>--single-transaction</code>时，会启动一个事务，确保拿到一致性视图。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>1.MySQL里有2种表级锁：<strong>表锁、元数据锁</strong>（meta data lock，MDL）</p><p>2.表锁语法<code>lock tables ... read/write</code>，可通过<code>unlock tables</code>主动释放表锁，</p><p>3.lock tables不仅限制别的线程读写，也限制本线程的操作；</p><p>4.MDL锁是系统默认会加的，<strong>作用防止DDL和DML并发的冲突</strong>，保证读写正确性，对一个表做增删改查时，加MDL读锁；对表结构变更时，加MDL写锁；即（MDL不需要显示使用，在访问一个表时自动加上）</p><p>5.MDL直到数据提交才会释放；</p><p>5.<strong>思考：给一个小表加个字段，导致整个库挂了？</strong></p><p>​    原因：先查询，加了MDL读锁，再改表结构，加了MDL写锁，两个事务都没提交，导致后续操作会阻塞，如果客户端重试，库的线程很快爆满。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>MySQL的行锁由各个存储引擎自己实现，如MyISAM不支持行锁，任何一个更新都会锁住整张表</p><p>两阶段锁协议：Innodb事务中，行锁在需要的时候才加上，需要等到事务结束时才释放，而不是不需要了立刻释放；</p><p><strong>死锁和死锁检测</strong></p><p>并发系统中，不同线程出现循环资源依赖，都在等待其他线程释放资源时，会进入无限等待状态，即死锁。</p><p>死锁有2种策略解决：</p><p>1.进入等待，直到超时，可通过参数<code>innodb_lock_wait_timeout</code>来设置，默认50s；</p><p>2.发起死锁检测，发现死锁后，主动回滚死锁链中的一个事务，使得其他事务能执行，设置参数<code>innodb_deadlock_detect</code>为on开启死锁检测；</p><p><strong>死锁检测带来的问题？</strong></p><p><code>当一个事务被锁，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现循环等待，即死锁</code>。假设1000个线程同时更新同一行，死锁检测的操作就是100万量级的，结果：CPU利用率很高，每秒执行事务却很少。</p><p>上述问题解决方式：</p><p>1.控制并发度（客户端控制可能不太行，因为客户端会有多个，如果有中间件，在中间件控制）</p><p>2.从业务设计上进行优化，将一行的改动逻辑分成多行，减少锁冲突；</p><p><strong>提问：</strong></p><p>1.死锁检测什么时候执行？ 在事务需要加锁访问的行上有锁，才要检测；一致性读不会加锁，故不需要死锁检测；</p><p>2.Innodb行级锁通过锁索引记录实现，如果update的列没建索引，即使update一条记录也会锁整张表吗？</p><p>  （隔离级别是RR，会的；隔离级别是RC，不会，MySQL做了优化的）</p><h2 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h2><p>事务查询数据，在这期间，即使数据被改过，但是事务看到的数据结果都是一致的。称为一致性读。</p><p>判断逻辑：</p><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，还有3种情况</p><p><code>1.版本未提交，不可见</code></p><p><code>2.版本已提交，但是是在视图创建后提交的，不可见；</code></p><p><code>3.版本已提交，且是在视图创建前提交的，可见;</code></p><p><strong>更新数据都是先读后写的，这个读只能读取当前值，即“当前读”</strong>。（更新和查询的区别）</p><p>例如：事务B执行更新语句，这期间事务C已经更新k=k+1，那么事务B更新时读到的k=2，更新后k=3;</p><p><strong>5.为什么rr能实现可重复读而rc不能,分两种情况</strong><br>(1)快照读的情况下,rr不能更新事务内的up_limit_id,<br>  而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id,则rc不能可重复读<br>(2)当前读的情况下,rr是利用record lock+gap lock来实现的,而rc没有gap,所以rc不能可重复读</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
